# Micro Frontend

- <https://www.youtube.com/watch?v=w0GFyJs5wO4>
- <https://newsletter.systemdesign.one/p/micro-frontends>
- <https://www.linkedin.com/pulse/building-micro-frontends-vite-module-federation-practical/>
- <https://www.linkedin.com/pulse/deep-dive-micro-frontend-architecture-homecreditvn/>

MicroFE slices the app into self-contained, domain-driven micro apps. The micro apps then get built, tested, and deployed independently. DOM gets shared between Micro Frontends.

Domain-driven design (DDD) is the key principle behind Micro Frontends. Put another way, each Micro Frontend represents a sub-domain.

Micro Frontends are usually set up with the backend for frontend (BFF) pattern. BFF pattern creates tailored backends for each Micro Frontend. But there is no need for a dedicated backend if the Micro Frontend consumes only a simple API.

## Problem with monolith

- Multiple teams work on a codebase
- More effort to build and deploy, even if with small change 

## Why

- Fast delivery due to isolated deployments
  - In monolith application, there is only one CI/CD pipeline. If there is just small changes, it will re-compile all the files within application => slow build and deployment time and the entire caching is invalidated
  - With micro-frontends, each application can have its own dedicated CI/CD process. Therefore, you only need to build and deploy the code that you have changed without impacting other parts of the application. Additionally, since other applications remain unchanged, there is no need to invalidate their cache, resulting in improved performance and a better user experience.
- Scalability & Single Responsibility: The app is divided into smaller modules and those modules are deployed independently with its own domain. Each team can own specific domains, and build, manage, and implement their own application.
- Reliability: modules are independent => if one module is crashed, the remaining applications can continue to function properly.
- Low initial load time because Micro Frontends get loaded on demand

## Disadvantage

- Cost: more repos, servers, domains
- Complex

## Sharing state between micro frontends

Micro Frontends shouldn't share their state but communicate via messages or events. Besides communication between Micro Frontends should be kept minimal to prevent coupling. The ways Micro Frontends could communicate with each other are:

- Custom events: MicroFE A dispatch custom event and microFE B listen to that event
- Passing callbacks
- Routing by using the address bar as a communication mechanism
- Web workers
- state management library: zustand

## How to implement

There are two ways:

- Build time integration: libraries are installed from npm and reused across microFE apps => duplicate packages and hard to maintain
- Run time integration: there is a host application that is responsible for rendering remote micro FE applications by downloading their bundle at runtime as needed

<img src="https://i.imgur.com/5KfsFmY.png">

There are lots of tools to implement MicroFE. The most popular among them is **Module Federation**

## Module Federation

Module Federation is an official feature of Webpack that allows loading remote modules from a web app shell.

### Terms

#### Container

In Webpack Module Federation, the term "container" refers to both the host and remote applications 

#### Host app

This app is like a wrapper and load all modules from remotes container. Basically it will do:

- Routing
- Authentication
- Render all MicroFE app and handle communication between them
- Should not do microFE business logic

### Remote app

The application that exposes federated modules for other apps to consume.

#### Federated Modules

A federated module is a module (JavaScript file, component, function, or even an entire app) that is exposed and consumed by different microfrontends. It can be anything: component, class or the whole app..., can be deployed anywhere and are loaded at runtime.

- "Federated" means "shared across multiple apps".
- A remote exposes modules, and a host consumes them.

#### Remote Entry (`remoteEntry.js`)

This is a special JavaScript file generated by Webpack Module Federation. It acts as a manifest that tells the host what modules are available and how to load them.

Think of `remoteEntry.js` as a "table of contents" for the remote app. It contains the list of exposed modules and shared dependencies info
When the host loads `remoteEntry.js`, it dynamically fetches exposed modules without needing a full page reload.

#### Shared Scope (__webpack_share_scopes__)

The shared scope is Webpack's way of handling shared dependencies (e.g., React, Lodash) across federated modules.

- Prevents multiple versions of the same library from being loaded.
- Ensures all federated apps use the same instance of a shared dependency.

How does it work?

- The host and remote declare shared dependencies.
- The first loaded app initializes the shared scope.
- Subsequent apps reuse existing instances instead of loading duplicates.

### Loading federated modules

There are two ways: static and dynamic. Both requires an index file and a bootstrap file.

```js
// index.ts
import('./bootstrap')
```

```js
// bootstrap.ts
// setup or just import exposed modules
import remoteApp/Button.
```

The purpose of using 2 seperate files is because:

- Module Federation requires asynchronous operations (e.g., loading remoteEntry.js, setting up shared modules).
- However, ReactDOM.render() or createRoot() is synchronous, meaning it can't wait for async operations inside the index.tsx file.
- Without a bootstrap file, your app might try to render before remotes are ready, causing errors like "remote not found" or "shared module not available."

#### Static Remotes (Predefined in webpack.config.js)

First, we need to setup the configuration in both host container and remote container

```js
// Remote Webpack Config (remote/webpack.config.js)
new ModuleFederationPlugin({
  name: 'remoteApp',
  filename: 'remoteEntry.js',
  exposes: {
    // './' is the convention of module federation.
    './Button': './src/Button', // Exposing a module: name_of_the_module: path_to_the_file
  },
});
``` 

```js
new ModuleFederationPlugin({
  name: 'host',
  remotes: {
    remoteAppContainer: 'remoteApp@http://localhost:3001/remoteEntry.js', // remoateAppContainer is like the alias of the remote container
  },
  shared: {
    react: { singleton: true, requiredVersion: '^18.0.0' },
    'react-dom': { singleton: true, requiredVersion: '^18.0.0' },
  },
});
```

- singleton: true → Ensures only one instance of React is used across all apps.
- requiredVersion → Ensures a compatible version is used.

Then inside host app, we import the module like this: `import remoteAppContainer/Button`

#### Dynamic loading

If the remote URL is dynamic or unknown at build time, you need to dynamically load `remoteEntry.js` at runtime without needing for a configuration like above For example, when you have multiple federated apps and you need to load them using only a function

In this way, we will create a script that will load `remoteEntry.js`

```ts
// host/src/loadRemote.ts
export const loadRemoteScript = (url: string, globalVar: string): Promise<void> => {
  return new Promise((resolve, reject) => {
    if (window[globalVar]) return resolve(); // Already loaded

    const script = document.createElement('script');
    script.src = url;
    script.type = 'text/javascript';
    script.async = true;
    script.onload = () => {
      console.log(`Remote ${globalVar} loaded!`);
      resolve();
    };
    script.onerror = () => reject(new Error(`Failed to load remote: ${url}`));
    document.head.appendChild(script);
  });
};
```

```tsx
import React, { useEffect, useState } from 'react';
import { loadRemoteScript } from './loadRemote';

declare global {
  interface Window {
    remoteApp?: any;
  }
}

const loadRemoteComponent = async (): Promise<React.FC> => {
  await loadRemoteScript('http://localhost:3001/remoteEntry.js', 'remoteApp'); // Dynamically load remoteEntry.js

  await __webpack_init_sharing__('default');
  const container = window.remoteApp;
  await container.init(__webpack_share_scopes__.default);
  const factory = await container.get('./Button');
  return factory().default;
};

const App: React.FC = () => {
  const [RemoteButton, setRemoteButton] = useState<React.FC | null>(null);

  useEffect(() => {
    loadRemoteComponent().then(setRemoteButton).catch(console.error);
  }, []);

  return (
    <div>
      <h1>Host Application</h1>
      {RemoteButton ? <RemoteButton /> : <p>Loading remote component...</p>}
    </div>
  );
};

export default App;
```

### When is `remoteEntry.js` is loaded?

- In Static Remotes loading (Predefined in webpack.config.js): `remoteEntry.js` loads when the host imports a remote module for the first time. The URL is already known in the configuration

```js
remotes: {
  remoteApp: 'remoteApp@http://localhost:3001/remoteEntry.js'
}
```

- Dynamic Remotes: `remoteEntry.js` is loaded manually using a `<script`> or `import()`

### Module Federation and Monorepo

- Monorepo shares code between application at build time
- Module Federation shares code at runtime

If you have a component that is used in three different applications in a monorepo and you want to ensure that a change to that component is deployed to all the applications you will need to redeploy all three applications from the monorepo. With Module Federation and runtime dependencies you deploy the component once and it is consumed by all three applications at runtime so the updating is instantaneous.

### Implement Module Federation in Vite

Basically, each remote app will be build and deploy serperately. The most important file of remote app is the `remoteEntry.js`. This file is created when you build the remote app that wrapped all the exposed code

Then in the host file you will declare them in the `federation()` config

```js
// vite.config.js of host app
export default defineConfig({
  plugins: [
    react(),
    federation({
      name: 'root-app',
      filename: 'root-app-entry.js', // This file will be created on build
      // These are the packages that will be used in all the modules
      // We share them so we won't load them multiple times
      shared: ['react', 'react-dom', 'react-router-dom', 'zustand'],
      // remotes are the remotes modules that host app needs to import
      remotes: {
        // 'product-app' is the name of product module defined in the federation config of product app
        'product-app': 'http://localhost:3001/dist/assets/product-app-entry.js',
      },
    }),
  ],
}

// vite.config.js of product app
export default defineConfig({
  plugins: [
    react(),
    federation({
      filename: 'product-app-entry.js',
      name: 'product-app',
      shared: ['react', 'react-dom', 'zustand'],
      // the list of components that you want to expose to public
      exposes: {
        './App': './src/App.tsx',
      },
    }),
  ],
}
```

### Update

When there is updates in the code of remote apps, it need to be build and deploy to create a new `remoteEntry.js`.

### Module Federation (or MicroFE) with TypeScript

If your project is using TS, there will be an 'Module not found' error when you import the code from other remote modules: 

```ts
// It will raise an error in your ide
import ProductApp from 'product-app/App';
import CartApp from 'cart-app/App';
```

You cannot also build and deploy your code due to this error.

In this case, you have to declare the types for your module, by creating a `*.d.ts`, ex: `global.d.ts`

```ts
declare module 'product-app/App';
declare module 'cart-app/store';
```

You can place this file in the root folder or in the `src` folder, just remember to include it in the `tsconfig.json` file

```json
{
  "compilerOptions": {
    // ....
  },
  "include": ["src"], // "include": ["src", "**/*.d.ts"] if you put the file in the root folder
}
```


## MicroFE shared components

It is important to avoid sharing business logic to prevent coupling.

Also a single team should own the shared component for high quality and consistency. But it should be kept open to contributions from every team.